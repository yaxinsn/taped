5.0.11
1 增加了skinny_del_session里检查skinn_session个数的日志。
2.close_skinny_session_by_Callid里del skinny session.
3. 不在使用handle_clear_prompt_status。
4. 在stop_media_transmistssion的stop_oneMedia时，发现了如果只有一个RTP会话，则直接使用close_dial_session_sniffer_lastone。
5. handle_CallState里的onHook过程，来关闭整个skinny session.调用close_skinny_session_by_Callid
5.0.11
6， handle_DialedNumber中要先判断是否skinny_find_session,再新建skinny_session。 
7.  在mix文件名称中增加mythreadid。

5.0.11上发现的问题：
5.0.11-A ： 
在代答+并席过程中，在并席过程（三方通话，一人挂机变两人通话的过程中，少一个两人通话的录音）
两人通话的过程中有start_media_transmission，无start_media_transmissionACK的报文，这样没有生成rtp的线程。
从日志上看，收到handle_start_media_transmission和handle_callinfo2_function两个报文之的后，
	日志开始处理 rtp线程开始处理信号，用于处理linear_list_mix+upload_the_mix_file的过程，同时启动了另一个upload线程（用于http上传文件）。upload_mix_file
	怀疑是upload线程占用CPU太长时间，导致skinny-sniffer线程丢失了start_media_transmissionACK的报文。

5.0.12
1. 增加skinny_media_list_lock。操作skinny里的media-session（passThruPartyID为key）时，要进行保护。一般不保护也无问题。因为handle_start_media_transmission一般都是串行的。
2.__start_rtp_sniffer改成为_skinny_start_rtp_sniffers


4.针对5.0.11-A问题的修改：
4.1 stop_oneMedia里的处理再修改回去。针对5.0.11里的4项修改。 为了解决5.0.11-A 的问题。暂时不上传并席之前三方通话的最后一个文件，而是在最后整个通话结束了，再上传。
4.2 handle_start_media_transmission里增加日志，打印出 before new skinny-media-session callrefer。
4.3 sniffer-rtp.c 里 finish_rtp中不再处理最后一文件。
4.4 sniffer-rtp.c 里 sighandler中，只有(n->exit_flag >= RTP_EXIT_STOP_SNIFFER_EXIT_PTHREAD)时才处理最后一文件。


5.0.13
可以增加pcap的buffer_size. pcap_set_buffer_size 为20M。timeout为1000ms.


5.0.16
1 可以增加pcaptimeout为0ms.
2 增加了重传机制。还是强制重传。每个文件只重传4次。由__upload_msg_handle来决定。


5.1.5
1 增加了watchdog-taped.sh

5.1.9
1 SIP中并席过程中有一个call_id有三次invate开始的过程，每一次都会更新IP和port. 但是call_id不变。这样可以一直使用call_id来管理sip session。在create_session_for_star98中，每来一次invate时，则关闭了sip和rtp的session.再打开一个新的sipsession，再生成一个新的RTP session. 新的SIP session中的serial_no不变，这样则乔的service可以把它们全组成一个录音。
2 把 _close_session(char* call_id)的参数改成call_id.
3,_close_session_for_star98 它专门被create_session_for_star98 调用，这样并席中间过程的rtp会话，使用close_dial_session_sniffer，只关闭rtp会话，但在上传时，不加last pack flag的标志。


5.1.10
增加time.c 用于取得时间间隔。
增加每一个报文的时间长。


5.1.11
1.不再使用pthread_kill机制。
2.子线程自己detached.    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
3. log里打印出自己的PID。
但是由于pcap 线程没停下来，所以录音没成功。



5.1.12 
解决了5.1.11的BUG 
	增加了pcap_stop 函数，让rtp session中的 pcap _while可以停下来。
问题是，从停下来到线程结束 需要10到20S的时间，导致上报的时间不准。
日志里增加pid-XXX.



5.1.13
open_pcap_file（）to_ms =100 也就 是0.1S
把ring_time的计算提前了。


